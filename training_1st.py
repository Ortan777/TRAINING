# -*- coding: utf-8 -*-
"""training_1st.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sfaKa1OWVEUH2LeoyNbyjJBAQoAbQ0Zx

# **Time Complexity Order (Best to Worst):**


O(1) - Constant time
(Example: Array access by index, Hash table lookup)

O(log n) - Logarithmic time
(Example: Binary search, Balanced BST operations)

O(n) - Linear time
(Example: Iterating through an array, Linear search)

O(n log n) - Linearithmic time
(Example: Efficient sorting algorithms like Merge Sort, QuickSort, HeapSort)

O(n²) - Quadratic time
(Example: Bubble Sort, Selection Sort, Insertion Sort - when worst case)

O(2ⁿ) - Exponential time
(Example: Recursive Fibonacci without memoization)

O(n!) - Factorial time
(Example: Brute-force solution for Traveling Salesman Problem)

##install thonny
"""

a,b,c="python"  # error
print(a,b,c)

*a,b,c="python"  #arbitraty variable
print(a,b,c)

a,*b,c="python"  #arbitraty variable
print(a,b,c)

#palindrome words

lst=['madam','apple','noon','malayalam']
print([w for w in lst if w==w[::-1]])

var='567'
print(list(var))

str='cbt','hyd'
print(str)

str='cbt''hyd'
print(str)

l1=['in','as','if','be']
print(l1[1:][:2])

n=int(input("enter the number of element:"))
mylist=list(map(int,input("enter [5] space seperated number:").split()))[:n]
print(mylist)

# chained comparisions

x=5
print(1<x<10)

#or
print(True if(x>1 and x<10)else False)

lst=['a','b','c','d']
for ele in lst:
  if ele=='b':
    lst.remove('b')
  else:
    print(ele)

    """Note: Modifying a list while iterating over it using a for loop can lead to unexpected behavior due to the changing size and indices of the list.
    In this specific case, when 'b' is removed, the loop continues from the next element in the original list's sequence, causing 'c' to be skipped and only 'd' to be printed after 'a'."""

x={}
y=[1,2]
z=[3,4]
print(x.fromkeys(y,z))

msg='python programing'
print(msg[-0])

print(min(0.0,-0,0))
print(min(-0.0,0.0))

num=[10,20,30,40,50]
num[1:4]=[90,45,30]
print(num)

print(1+True)

values=('a1','b2','c3')
print(dict(values))

value=('a4','a2','a3')
print(dict(value))

#python allows multiple value to be returned
def add(a,b):
  return a+5,b+5
result=add(3,2)
print(result)

x=y=z=10
print(x,y,z)
x,y,z=10,20,30
print(x,y,z)
x=10,20,30
print(x)

x=[[]]*2
x[1].append(2)
print(x)
y='python'  #the above thing is similar to this
print(y*2)

def multiply(a,b):
  return a*b
result=multiply(5,0) or multiply(3,12) #true value will be assigned to results other than 0 all other nums are true
print(result)

*_,='python'  #pistol operator
print(_)

'''That's a fun, informal name that some people use for the * symbol when it's used in a special way in Python.
The * is like the tool that helps you scoop up all those letters and put them into the bag (_).
So, the "pistol operator" (*) is just a nickname for this scooping action that puts multiple things from a sequence
(like a string or a list) into a single variable, usually as a list.It helps you grab the "rest" of the items.'''

a=3
b=1
for c in range(2,6):
  a=a-c
  a=a+c
print(a+b)

a=(10,20,30)
b=(40)    #will cause an error bcz a is a tuple and b is an int and int and tuple cannot be concatinated
print(a+b)

#but
a=(10,20,30)
b=(40,)    #since , is present it makes b tuple so it will get concatinated
print(a+b)

list1=['1.0','a','0.1','1','-1']   #sorting lists
list2=sorted(list1)
print( list2 )

#swapping two values

a=5
b=10
a=a^b
b=a^b
a=a^b
print(a,b)

def solve(a):
  return a[-1]
a={1,2,3,4}   #  set (not dictionary cz it does not have keys) set is unordered and dosent have index so it throws error
print(solve(a)**2)

A=10
a='10'
print(str(A)==a)

print(isinstance('True',str))

x=0.1
y=0.2
print((x+y)==True) #0.1+0.3 will be considered as 0 and 0(false)==true is false

str1='python learning'
str2=str1[:5]*2+str1[:4]
str3=str2[:5//2]*3
print(str3)

a=[1,2,3,5]
if a.sort()==sorted(a):
  print("cow")
else:
  print("dog")

x=['ab','cd']
for i in x:
  x.append(i.upper())
print(x)

''' forms an infinite loop caps ab and cd will be pushed inside the lisst even ht will be added as x so it keeps on add8ing'''

data={
    'name':'sumanth',
    'branch':'cse',
    'skills':'python'
}
print(data['name'])
print(data['email'])

str='python'
print(str)
x=100
y=str(x)  # basically this is type conversion but since we declared a variable named str so it throws error
print(y)

"""###**Given a number ,check wether it is palindrome or not.**



"""

n=int(input("enter a number"))
t=n
rev=0
while(n>0):
  d=n%10
  rev=rev*10+d
  n=n//10
if(t==rev):
  print("palindrome")
else:
  print("not palindrome")

"""This code checks if a given number is a palindrome. Here's how it works:

n=int(input("enter a number")): It prompts the user to enter a number and stores it as an integer in the variable n.
t=n: It stores the original number in variable t for later comparison.

rev=0: It initializes a variable rev to 0, which will store the reversed number.


while(n>0):: It starts a loop that continues as long as n is greater than 0.


d=n%10: It extracts the last digit of n using the modulo operator (%) and stores it in d.


rev=rev*10+d: It builds the reversed number by multiplying rev by 10 and adding the extracted digit d.
n=n//10: It removes the last digit from n using integer division (//).


if(t==rev):: After the loop finishes, it compares the original number (t) with the reversed number (rev).
print("palindrome"): If they are equal, it prints "palindrome".


else: print("not palindrome"): Otherwise, it prints "not palindrome".

### **Input a number, find the sum of digits to a single digit**
"""

a=int(input("enter a number"))
while a>9:
  sum=0
  n=a
  while n>0:
    r=n%10
    sum+=r
    n=n//10
  a=sum
print(sum)

"""This code takes an integer input from the user and calculates the sum of its digits repeatedly until a single-digit sum is obtained.

Here's a breakdown of how it works:

1.  **`a=int(input("enter a number"))`**: Prompts the user to enter a number and converts it to an integer, storing it in `a`.
2.  **`while a>9:`**: This outer loop continues as long as the value of `a` is greater than 9.
3.  **`sum=0`**: Initializes `sum` to 0 at the beginning of each outer loop iteration.
4.  **`n=a`**: Creates a temporary variable `n` with the current value of `a` to avoid modifying `a` directly during digit summation.
5.  **`while n>0:`**: This inner loop iterates through the digits of `n`.
6.  **`r=n%10`**: Extracts the last digit of `n`.
7.  **`sum+=r`**: Adds the extracted digit to `sum`.
8.  **`n=n//10`**: Removes the last digit from `n`.
9.  **`a=sum`**: After the inner loop, the calculated `sum` is assigned back to `a`. This is the crucial step that updates the number for the next iteration of the outer loop.
10. **`print(sum)`**: Once the outer loop condition `a>9` is no longer true (meaning `a` is a single digit), the final `sum` (which is now the single-digit result) is printed.

### **Input a number, check wether it is amstrong number or not**

if sum of each digit power its length is equallent to the same number, then it is an amstrong number,ex 3^3+5^3+1^3->153
"""

del str  #cz ive used str above

# Program to find whether a number is armstrong or not
n=int(input("Enter a number: "))
t=n
sum=0
l=len(str(n))
while(n>0):
    rem = n%10
    sum = sum + rem**l
    n//=10
if sum == t:
    print("Armstrong number")
else:
    print("Not an armstrong number")

"""This code checks if a given number is an Armstrong number. Here's a breakdown of how it works:

1.  **`n=int(input("Enter a number: "))`**: Prompts the user to enter a number and converts it to an integer, storing it in `n`.
2.  **`t=n`**: Stores the original number in variable `t` for later comparison.
3.  **`sum=0`**: Initializes a variable `sum` to 0, which will store the calculated sum of the digits raised to the power of the number of digits.
4.  **`l=len(str(n))`**: Converts the number `n` to a string to find its length (the number of digits). This length is stored in variable `l`. This is crucial for checking Armstrong numbers of any number of digits.
5.  **`while(n>0):`**: Starts a loop that continues as long as `n` is greater than 0. This loop iterates through each digit of the number.
6.  **`rem = n%10`**: Extracts the last digit of `n` using the modulo operator (`%`) and stores it in `rem`.
7.  **`sum = sum + rem**l`**: Raises the extracted digit (`rem`) to the power of the number of digits (`l`) and adds it to the `sum`.
8.  **`n//=10`**: Divides `n` by 10 using integer division (`//`) to remove the last digit and move to the next digit in the number.
9.  **`if sum == t:`**: After the loop finishes, it compares the calculated `sum` with the original number (`t`).
10. **`print("Armstrong number")`**: If they are equal, it prints "Armstrong number".
11. **`else: print("Not an armstrong number")`**: Otherwise, it prints "Not an armstrong number".

This code is a correct implementation for checking if a number is an Armstrong number for any number of digits because it dynamically calculates the number of digits (`l`) and uses that as the exponent.

### **write all the amstrong number bw 1-1000**
"""

num=1
while num<=1000:
  n=numsum=0

  while n>0:
    r=n%10
    sum=sum+r*r*r
    n=n//10
if sum==num:
    print(f'{num}')

"""# Wrong Subtraction


time limit per test1 second

memory limit per test256 megabytes

Little girl Tanya is learning how to decrease a number by one, but she does it wrong with a number consisting of two or more digits. Tanya subtracts one from a number by the following algorithm:


if the last digit of the number is non-zero, she decreases the number by one;
if the last digit of the number is zero, she divides the number by 10 (i.e. removes the last digit).

You are given an integer number n

. Tanya will subtract one from it k

 times. Your task is to print the result after all k
 subtractions.

It is guaranteed that the result will be positive integer number.


Input

The first line of the input contains two integer numbers n
 and k
 (2≤n≤109
, 1≤k≤50
) — the number from which Tanya will subtract and the number of subtractions correspondingly.

Output

Print one integer number — the result of the decreasing n
 by one k
 times.

It is guaranteed that the result will be positive integer number.

Examples
Input
512 4
Output
50
Input
1000000000 9

Output
1

Note
The first example corresponds to the following sequence: 512→511→510→51→50
.



"""

a,b=map(int,input().split())
for _ in range(b):
  if a%10==0:
    a//=10
  else:
    a-=1
print(a)

"""#**LIST**

LIST IS AN ORDERED COLLECTION OF ITEM

ITEMS COULD BE OF ANY PYTHON DATA TYPE
10,'PYTHON',10.0

## Insertion into list

append():
add element to the end of the list



extend():
add all element of a list into another list



insert():
insert an item at a defined index

## Removal from list

remove():
remove an element by its value from the list


pop():
removes the last item form the list or removes an item by its index from the list


clear():
removes all items fron the list


##List methods

index():
returns the index from the list

count():
returns the count of number of items passed as an argument

copy():
returns the copy of the list

sort():
sorting the order of the item in the list

reverse():
reversing the list

## list built in function

all():
returns true if all the elements is true or if list is emoty

any():
returns true if any element of the list is true .if the list is empty return false

len(): returns the length of the list

sum(): returns the sum of the list

min(): returns the minimum value there in the list

max():returns the maximum value there in the list

# Slicing in a list

L [:]     prints all the elements in the list

L [2:]    prints all the elements from the list starting from the index 2

L [:5]    prints all the elenment from the list till the ending index 4

L [2:6]   prints all the elements from the list from index 2 to 5

L [-4:-2] prints the element from the list from index -4 till index -3

L [::2]    prints all the elements from the list with step (index+2 elements)from the begining

L [::-1]   prints all the elements from the list with step 1(index+1) from the last

L [1:6:3]  prints all the elements from the list from index+1 till index 5 with step 3




tuple and list are same but list is modifyable while tuple is not
"""

# methods of giving input to list
# 1

ls=[1,2,3,4,5,6]
print(ls)

# 2
ls=list(map(int,input().split()))
print(ls)

# 3
l=input('enter the elements').split()  # this method by default takes input in the form of string to change tht we need to use the above mentioned map method
print(l)

# 4
l=[]
n=int(input("enter the number of the element"))
for i in range(n):
  k=int(input("enter the element"))
  l.append(k)
print(l)

4# small probllem
l=[1,2,3,4,5]
for i in range(1,4):
  l[i-2]=l[i]
for i in range(0,4):
  print(l[i],end=" ")

l=[1,2,3,4,]
l.append(1)            # adds element in the end
print(l)

# or
l.append([1,2,3,4])     #adds the entire thing with 1 index at the end
print(l)

l.extend([1,2,3,4])      # adds all the elements with each having 1 index dosent work for one element if one element is gven inside extend then throws error
print(l)

l.insert(2,'python')   # insert at mentioned position
print(l)

l.pop()                 # removes elements from the end
print(l)

l.remove('python')              # removes the mentioned element
print(l)

l.pop(5)             # removes element from the mentioned index
print(l)

l.clear()            # removes all the element from the list

l=[15,2,10,5,2,3,]
print(l.index(2))

print(l.count(2))

l1=l.copy()
print(l1)

l2=l.sort()
print(l)       # if print(l2) is given then it wont be printed why?

l2=l.sort(reverse=True)
print(l)

# slicing

l=[1,2,3,4,5,6]
print(l[:])
print(l[2:])
print(l[:5])
print(l[2:6])
print(l[-4:-2])
print(l[::2])
print(l[::-1])

"""#1) TAKE 2 DIFFERENT LISTS ,MERGE THEM AND PRINT A NEW SORTED LIST"""

l1=list(map(int,input("enter the elements of stack").split()))
l2=list(map(int,input("enter the elements of stack").split()))
l3=l1+l2
l3.sort()
print(l3)

"""# 2) Display the sum of even integers present in the odd index in a list"""

l=[2,1,2,3,4,5,6,7,2]
sum=0
for i in range(len(l)):
  if i%2!=0 and l[i]%2==0:
    sum+=l[i]
print(sum)

"""# 3)Print the list after deleting the duplicate elements  in it"""

l1=list(map(int,input().split()))
l2=[]
for i in l1:
  if i not in l2:                        ## how to use in and not in in lists
    l2.append(i)
print(l2)

"""#4)Print the elements in the list which are occured odd number of times

"""

l1=list(map(int,input().split()))
l2=[]
for i in range(len(l1)):
  if l1[i]%2!=0 and l2 not in l1:
    l2.append(l1[i])
print(l2)

"""# 5)read a list and print the sum of 3 minimum elements in the list |"""

del sum

a=list(map(int,input().split()))
a.sort()
print(sum(a[:3]))

"""#6) print the list where even number in ascending order in one list and odd numbers in decending order and at last concatinate both"""

l=list(map(int,input().split()))
l.sort()
res=[]
for i in l:
  if i%2!=0:
    res.append(i)
  else:
    res.insert(0,i)
print(res)

"""#6)find the sum of last k elements of t he list"""

k= int(input("enter the number "))
l1=list(map(int,input().split()))
print(sum(l1[-k:]))

"""#7) check if the list contains consecutive number and return true"""

l1=list(map(int,input().split()))
for i in range(len(l1) - 1): # Loop up to the second to last element
  if l1[i+1]-l1[i]!=1:
    print("false")
    break
else:
  print('true')

"""#8) Police Recruits
time limit per test1 second

memory limit per test256 megabytes

The police department of your city has just started its journey. Initially, they don’t have any manpower. So, they started hiring new recruits in groups.

Meanwhile, crimes keeps occurring within the city. One member of the police force can investigate only one crime during his/her lifetime.

If there is no police officer free (isn't busy with crime) during the occurrence of a crime, it will go untreated.

Given the chronological order of crime occurrences and recruit hirings, find the number of crimes which will go untreated.

Input
The first line of input will contain an integer n (1 ≤ n ≤ 105), the number of events. The next line will contain n space-separated integers.

If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.

Output

Print a single integer, the number of crimes which will go untreated.

Examples

Input

3

-1 -1 1

Output

2

Input

8

1 -1 1 -1 -1 1 1 1

Output

1

Input

11

-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1

Output

8

Note

Lets consider the second example:


Firstly one person is hired.

Then crime appears, the last hired person will investigate this crime.

One more person is hired.

One more crime appears, the last hired person will investigate this crime.

Crime appears. There is no free policeman at the time, so this crime will go
untreated.

One more person is hired.

One more person is hired.

One more person is hired.

The answer is one, as one crime (on step 5) will go untreated.


"""

n=int(input( ))
l=list(map(int,input().split()))
police=0
crime=0
unsolved=0
for i in l:
  if  i==-1:
    if police>0:
      police-=1
    else:
      unsolved+=1
  else:
    police+=i
print(unsolved)

"""This code helps track how many crimes go unsolved when police officers are hired and crimes occur.

Here's the simple idea:

*   We start with no police officers and no unsolved crimes.
*   We look at each event one by one.
*   If a positive number appears, it means new police officers are hired, so we add them to our count of available police.
*   If a -1 appears, it means a crime happened.
    *   If we have police officers available, one officer deals with the crime, and our available police count goes down by one.
    *   If we have no police officers available, the crime cannot be solved, and we add one to our count of unsolved crimes.
*   Finally, we print the total number of crimes that couldn't be solved because there were no police available at that moment.

"""

l=list(map(int,input().split()))
m,count=0,0
for i in l:
  if i>m:
    m=i
    count+=1
print(count)

"""#9)remove the second largest element in the list"""

l=list(map(int,input().split()))
m,n=0,0
for i in l:
  if i>m:
    m=i
for i in l:
  if i>n and i!=m:
    n=i

print(n)


# optimized

l=list(map(int,input().split()))
m,n=0,0
for i in l:
  if i>m:
    n=m
    m=i
  elif i>n and i!=m:
    n=i


print(n)

"""#10)get an input and find the exor of the sequence ex input is 5 return 1^2^3^4^5"""

n= int(input('enter a num"'))
if n%4==1:
  print(1)
elif n%4==2:
  print(n+1)
elif n%4==3:
  print(0)
elif n%4==0:
  print(n)

4%5

5%4

"""#11)a number will be given in integer form check the number of one in its binary form"""

n=int(input("enter a number"))
count=0
while(n):
  n=n&(n-1)
  count+=1
print(count)

"""#12)write a code to find a prime number in the list"""

def is_prime(n):
  if n <= 1:
    return False
  # The loop to check for divisors should be here, outside the first if block
  for i in range(2, int(n**0.5) + 1):
    if n % i == 0:
      return False
  return True # If the loop completes without finding a divisor, the number is prime

l=[5,8,10,12,4,3,7]
count=0
for i in l:
  if is_prime(i):
    count+=1
print(count)

"""This code defines a function `is_prime` to check if a number is prime and then uses this function to count the prime numbers in a list.

Here's how it works:

1.  **`def is_prime(n):`**: Defines a function `is_prime` that takes an integer `n` as input.
2.  **`if n <= 1:`**: Checks if the number is less than or equal to 1. Numbers less than or equal to 1 are not prime.
3.  **`return False`**: If `n` is less than or equal to 1, the function returns `False`.
4.  **`for i in range(2, int(n**0.5) + 1):`**: This loop checks for divisors of `n` starting from 2 up to the square root of `n`. We only need to check up to the square root for efficiency.
5.  **`if n % i == 0:`**: Inside the loop, this checks if `n` is divisible by `i` without a remainder. If it is, `n` has a divisor other than 1 and itself, so it's not prime.
6.  **`return False`**: If a divisor is found, the function immediately returns `False`.
7.  **`return True`**: If the loop finishes without finding any divisors, it means `n` is prime, and the function returns `True`.
8.  **`l=[5,8,10,12,4,3,7]`**: This is the list of numbers that will be checked for primality.
9.  **`count=0`**: Initializes a counter to keep track of the prime numbers found.
10. **`for i in l:`**: This loop iterates through each number in the list `l`.
11. **`if is_prime(i):`**: Calls the `is_prime` function for each number in the list.
12. **`count+=1`**: If the function returns `True` (meaning the number is prime), the counter is incremented.
13. **`print(count)`**: Finally, prints the total count of prime numbers in the list.
"""

print(1)

print(123)

a(123)

a = print
a(1)

a

b=print
b(123)

"""#13) A dislike of threes

Polycarp doesn't like integers that are divisible by 3
 or end with the digit 3
 in their decimal representation. Integers that meet both conditions are disliked by Polycarp, too.

Polycarp starts to write out the positive (greater than 0
) integers which he likes: 1,2,4,5,7,8,10,11,14,16,…
. Output the k
-th element of this sequence (the elements are numbered from 1
).

Input

The first line contains one integer t
 (1≤t≤100
) — the number of test cases. Then t
 test cases follow.

Each test case consists of one line containing one integer k
 (1≤k≤1000
).

Output

For each test case, output in a separate line one integer x
 — the k
-th element of the sequence that was written out by Polycarp.

input:
10

1

2

3

4

5

6

7

8

9

1000

output:

1

2

4

5

7

8

10

11

14

1666
"""

a=int(input())
for i in range(a):
  a1=int(input())
  i,count=1,0
  while(1):
    if i%10!=3 and i%3!=0:
      count+=1
      if count==a1:
        print(i)
        break
    i+=1

"""# **SET**
 a set is an unordered collection of data type that is iterable ,mutable and has no duplicate elements

 sets can be used to perform mathematical set operations like union,intersection,symmetric difference etc


modifying is not allowed in set

delete is possible

set inside a set is not possible

## set methods
add(): adds an element to the set

update(): updates the set with union of itself and others

copy(): returns a copy of the set

clear(): removes all the element fromm the set

remove(): removes an element from the set if the member is not the member then raise the error

pop(): removes and returns an arbitrary set element raise key error if the set is empty

discard(): removes an element from the set if it is a member (do nothing if the element is not in set )

union(): returns a union of set in a new set

intersection(): returns the intersection of two sets as a new set

intersection_update(): updates the set within the intersection of itself and another

difference(): returns the difference of two or more sets as a new sets

difference_update(): removes all element of anothe set from this set

symmetric_difference(): returns the symmetric difference of two sets as a  new set

symmetric_difference_update(): updates the symmetric difference of itself and another

is_disjoint(): returns true if two sets have a null intersection

is_subset(): returns true if another set contains this set

is superset(): returns true if this set contains another set

sum(): returns the sum of the set

max(): returns the maximum element in the set

min(): returns the minimum element in the group

all(): returns true if all elements ofg the set are true

any(): return true if any element of the set is true if the set is empty return false

sorted():  return a new sorted list from elements in the set( does not sort the set itself)

##creating a set
"""

s=set()# empty set
print(s)
print(type(s))

s=set([1,2,'hi','bye'])       # create set with set[]
print(s)

s={1,2,3,4,5,6}       # create set with {}
print(s)

s=set([1,2,'hi',3,'bye'])
print(s)

fruits = {'apple', 'banana'}
fruits.add('orange')                                            # add()
print(fruits)  # Output: {'apple', 'banana', 'orange'}

fruits = {'apple', 'banana'}
fruits.update(['orange', 'mango'])                                #update
print(fruits)  # Output: {'apple', 'banana', 'orange', 'mango'}

fruits = {'apple', 'banana'}
fruits_copy = fruits.copy()                                       #copy
print(fruits_copy)  # Output: {'apple', 'banana'}

fruits = {'apple', 'banana'}
fruits.clear()                                                   #clear
print(fruits)  # Output: set()

fruits = {'apple', 'banana'}
fruits.remove('apple')
print(fruits)  # Output: {'banana'}                              #remove

# fruits.remove('pear')  # This would raise KeyError

fruits = {'apple', 'banana', 'orange'}
item = fruits.pop()                                              #pop
print(item)    # Output: random element (e.g., 'banana')
print(fruits)  # Output: remaining elements (e.g., {'apple', 'orange'})

fruits = {'apple', 'banana'}
fruits.discard('apple')
print(fruits)  # Output: {'banana'}                              # discard

fruits.discard('pear')  # No error raised
print(fruits)  # Output: {'banana'}

set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2)                                      #union
print(union_set)  # Output: {1, 2, 3, 4, 5}

set1 = {1, 2, 3}
set2 = {2, 3, 4}
intersect_set = set1.intersection(set2)                           #intersection
print(intersect_set)  # Output: {2, 3}

set1 = {1, 2, 3}
set2 = {2, 3, 4}
set1.intersection_update(set2)                                    #intersection_update
print(set1)  # Output: {2, 3}

set1 = {1, 2, 3, 4}
set2 = {3, 4, 5}
diff = set1.difference(set2)                                      #difference
print(diff)  # Output: {1, 2}

set1 = {1, 2, 3, 4}
set2 = {3, 4, 5}
set1.difference_update(set2)                                     #difference_update
print(set1)  # Output: {1, 2}

set1 = {1, 2, 3}
set2 = {3, 4, 5}
sym_diff = set1.symmetric_difference(set2)                        #symmetric_difference
print(sym_diff)  # Output: {1, 2, 4, 5}

set1 = {1, 2, 3}
set2 = {3, 4, 5}
set1.symmetric_difference_update(set2)                           #symmetric_difference_update
print(set1)  # Output: {1, 2, 4, 5}

set1 = {1, 2}
set2 = {3, 4}
print(set1.isdisjoint(set2))  # Output: True                       #isdisjoint

set3 = {2, 3}
print(set1.isdisjoint(set3))  # Output: False

set1 = {1, 2}
set2 = {1, 2, 3}
print(set1.issubset(set2))  # Output: True                         #issubset

set3 = {1, 4}
print(set1.issubset(set3))  # Output: False

set1 = {1, 2, 3}
set2 = {1, 2}
print(set1.issuperset(set2))  # Output: True                        # issuperset

set3 = {1, 4}
print(set1.issuperset(set3))  # Output: False

nums = {1, 2, 3, 4}
print(sum(nums))  # Output: 10                                       #sum

nums = {5, 2, 8, 1}
print(max(nums))  # Output: 8                                         #max

nums = {5, 2, 8, 1}
print(min(nums))  # Output: 1                                        #min

set1 = {True, 1, 'non-empty'}
print(all(set1))  # Output: True

set2 = {True, 0, 'non-empty'}
print(all(set2))  # Output: False                                  #all

set1 = {False, 0, ''}
print(any(set1))  # Output: False

set2 = {False, 1, ''}
print(any(set2))  # Output: True                                  #any

nums = {5, 2, 8, 1}
sorted_nums = sorted(nums)
print(sorted_nums)  # Output: [1, 2, 5, 8]
print(nums)         # Output: {1, 2, 5, 8} (original set unchanged)

letters = {'c', 'a', 'b'}
print(sorted(letters))  # Output: ['a', 'b', 'c']                       #sorted

"""# DICTIONARY

a dictionary is a collection which is unordered changable and indexed

in python dictionaries are written with curly braces and they have keys and values

ACESSING ELEMENT BY USING GET METHOD

only values in dictionary can be changed but keys should be immutable

##methods in dictionary

get(): its a conventional method to acess a value for a key

update(): adds dictionary dict2's key value pairs to dict

copy(): the copy method returns a shallow copy of the dictionary

pop(): removes and returns an element from the dictionary having the given key

popitem(): removes the arbitrary key value pair from the dictionary and returns it as tuple

clear(): the clear method removes all the items from the dictionary

keys(): returns list of dictionary dict's keys

values(): returns a list of alll the values available in a given dictionary

items(): returns a list of dictionary (key,value) tuple pairs

fromkeys(): create a new dictionary with keys from seq and values set to values

setdefault(): set dict[key]=default if key is not already in dict


"""

d={}
n=int(input("enter the num of elements"))
for _ in range(n):
  key=int(input("enter the key "))
  value=input("enter the value")
  d[key]=value
print(d)

## ACESSING ELEMENTS INSIDE DICTIONARY

company = {
    'name': 'TechCorp',
    'departments': {
        'sales': 50,
        'engineering': 120
    }
}

# Safe access to nested dictionary
print(company.get('departments', {}).get('engineering'))
print(company.get('departments', {}).get('marketing'))

student = {'name': 'John', 'age': 21, 'course': 'Computer Science'}

print(student.get('name'))      # Output: 'John'                           #get
print(student.get('grade'))     # Output: None
print(student.get('grade', 'A'))  # Output: 'A' (default value)

dict1 = {'a': 1, 'b': 2}
dict2 = {'b': 3, 'c': 4}                                                  #update

dict1.update(dict2)
print(dict1)  # Output: {'a': 1, 'b': 3, 'c': 4}

original = {'x': 1, 'y': 2}
copied = original.copy()                                           # copy

copied['x'] = 10
print(original)  # Output: {'x': 1, 'y': 2}
print(copied)    # Output: {'x': 10, 'y': 2}

inventory = {'apples': 10, 'bananas': 5, 'oranges': 8}

removed = inventory.pop('bananas')                                #pop
print(removed)     # Output: 5
print(inventory)   # Output: {'apples': 10, 'oranges': 8}

# inventory.pop('pears')  # Raises KeyError

colors = {'red': '#FF0000', 'green': '#00FF00', 'blue': '#0000FF'}

item = colors.popitem()                                                     # popitem
print(item)    # Output: ('blue', '#0000FF') (or another random item)
print(colors)  # Output: remaining items

temp = {'a': 1, 'b': 2}
temp.clear()                                                               # clear
print(temp)  # Output: {}

car = {'brand': 'Toyota', 'model': 'Corolla', 'year': 2020}

print(car.keys())  # Output: dict_keys(['brand', 'model', 'year'])          # keys
print(list(car.keys()))  # Output: ['brand', 'model', 'year']

car = {'brand': 'Toyota', 'model': 'Corolla', 'year': 2020}

print(car.values())  # Output: dict_values(['Toyota', 'Corolla', 2020])     #values
print(list(car.values()))  # Output: ['Toyota', 'Corolla', 2020]

car = {'brand': 'Toyota', 'model': 'Corolla', 'year': 2020}

print(car.items())                                                                    #items
# Output: dict_items([('brand', 'Toyota'), ('model', 'Corolla'), ('year', 2020)])

for key, value in car.items():
    print(f"{key}: {value}")

keys = ['a', 'b', 'c']
default_dict = dict.fromkeys(keys)                                                              #fromkeys
print(default_dict)  # Output: {'a': None, 'b': None, 'c': None}

value_dict = dict.fromkeys(keys, 0)
print(value_dict)    # Output: {'a': 0, 'b': 0, 'c': 0}

employee = {'name': 'Alice', 'age': 28}

# Key exists - returns current value
print(employee.setdefault('name', 'Unknown'))  # Output: 'Alice'                                 #setdefault

# Key doesn't exist - sets and returns default
print(employee.setdefault('department', 'HR'))  # Output: 'HR'
print(employee)  # Output: {'name': 'Alice', 'age': 28, 'department': 'HR'}

""" # 14)write a program to check wether the given key already existsd in in a dictionary"""

d={}
n=int(input("enter the num of elements"))
for _ in range(n):
  key=int(input("enter the key "))
  value=input("enter the value")
  d[key]=value
key=input()
if key in d:
  print("present")
else:
  print("not present")

"""#15) write a python program to generate and print a dictionary that contains a number"""

d={}
n=int(input("enter the num of elements"))
for _ in range(n):
  key=int(input("enter the key "))                    #or
  value=key**2
  d[key]=value

print(d)

d={}
n=int(input("enter the range"))
for i in range(1,n+1):
  d[i]=i*i
print(d)

"""leetcode 88  

two pointer approach
"""

l=[1,6,9,5]
for i in range(len(l)):
  for j in range(i+1,len(l)):
    print(l[i],l[j])

"""maximim pair in the list"""

l=[1,6,9,9,5,5]
m1=m2=0,0
for i in l:
  if i>m1:
    m2=m1
    m1=i
  elif i>m2:
    m2=i
print(m1+m2)

"""16)electionns are conducted in a town that has population n .all the people  
in the town cast vote to different candidates in the  town the people ofg the town later realized tht the votes of only the candidaates 18 or above years of age are considered find out the candidate who iis tht wilnner if only the votes of age group  18 and above are considered if the winner cannot be decided or if there is a tie print -1. you you are given an array vote which representative the candidate to whom the vote is given by the i th person and another array of age which represents the age of that particular voter

"""

n= int(input())
vote=list(map(int,input().split()))
age=list(map(int,input().split()))
c=[0]*max(vote)
for i in range(n):
  if age[i]>=18:
    c[vote[i]-1]+=1
temp=sorted(c,reverse=True)
if temp[0]==temp[1]:
  print(-1)
else:
  print(c.index(temp[0])+1)

"""#17)check wether the list is sorted or not

"""

l=list(map(int,input().split()))
for i in range(len(l)-1):
  if l[i]>=l[i+1]:
    print("not sorted")
    break
else:
  print("sorted")

"""#**PATTERNS**

##1)sliding window pattern

#18)return the maximum sum of the group of 4 in the list
"""

books=[2,3,4,1,2,6,7,3,5,1,6,3,2,4]
k=4
t=[]
for i in range(len(books)):
 for j in range(i,i+k):
  t.append(sum(books[i:j+1]))
print(max(t))

books=[2,3,4,1,2,6,7,3,5,1,6,3,2,4]                #or
k=4
m=0
for i in range(len(books)-k+1):
  sum=0
  for j in range(i,i+k):
    sum+=books[j]
    m=max(m,sum)
print(m)

# by using  fixed sliding window pattern                                 #or time complexity n*k
#removing first book adding k+1 th book
books=[2,3,4,1,2,6,7,3,5,1,6,3,2,4]
k=4
s=0
for i in range (k):
  s+=books[i]
m=s
for i in range(1,len(books)-k+1):
  s=s-books[i-1]+books[i+k-1]
  m=max(m,s)
print(m)

"""This code calculates the maximum sum of a contiguous subarray of size `k` within the `books` list using the sliding window pattern.

Here's a breakdown of the code:

1. **`books=[2,3,4,1,2,6,7,3,5,1,6,3,2,4]`**: This is the input list of numbers.
2. **`k=4`**: This is the size of the window (the number of consecutive elements) we want to consider.
3. **`s=0`**: Initializes a variable `s` to store the sum of the current window.
4. **`for i in range (k): s+=books[i]`**: This loop calculates the sum of the first window of size `k`.
5. **`m=s`**: Initializes a variable `m` to store the maximum sum found so far, initially set to the sum of the first window.
6. **`for i in range(1,len(books)-k):`**: This loop iterates through the rest of the list, effectively sliding the window. The loop starts from index 1 because the first window (from index 0 to k-1) has already been processed. The loop ends at `len(books)-k+1` because that's the last possible starting index for a window of size `k`.
7. **`s=s-books[i-1]+books[i+k-1]`**: This is the core of the sliding window technique. In each iteration, we subtract the element that is leaving the window (`books[i-1]`) and add the new element that is entering the window (`books[i+k-1]`). This efficiently updates the sum of the current window without recalculating the entire sum each time.
8. **`m=max(m,s)`**: This line compares the current window's sum (`s`) with the maximum sum found so far (`m`) and updates `m` if `s` is greater.
9. **`print(m)`**: Finally, this line prints the overall maximum sum of any contiguous subarray of size `k`.

**Sliding Window Pattern**

The sliding window pattern is an algorithmic technique used to solve problems that involve a contiguous subarray or substring of a given size. It works by maintaining a "window" of a fixed or variable size that slides over the data. Instead of recalculating the result for each possible subarray, the sliding window technique efficiently updates the result as the window moves, typically by subtracting the element leaving the window and adding the element entering the window. This reduces the time complexity of the algorithm significantly.

time complexity:O(k+n)

##19) find the max subarray whose sum is less than or equal to k
we will be using dynamic sliding window pattern
"""

l=[2,3,4,5,2,1]
for i in range(len(l)):       #   to find all the subarray
  print(" ")
  for j in range(i,len(l)):
    print(l[i:j+1],end="   ")

# code for question
arr=[2,4,5,6,3,2,4,2,1,8,7,9]
k=13
l,r,sum,m=0,0,0,0
while r<len(arr):
  sum+=arr[r]
  while sum>k:
    sum=sum-arr[l]
    l=l+1
  m=max(m,sum)
  r+=1
print(m)

"""#20)most frequent element by using hashing method"""

l=list(map(int,input().split()))
m=0
d={}
ele=0
for i in l:
  if i not in d:
    d[i]=1
  else:
    d[i]+=1
for k in d:
  if d[k]>m:
    m=d[k]
    ele=k
print(ele)

"""#21)2nd most frequent element by using hash method"""

m,m1=0,0
ele,ele1=0,0
d={}
l=list(map(int,input().split()))
for i in l:
  if i not in d:
    d[i]=1
  else:
    d[i]+=1
for k in d:
   if d[k]>m:
       m1=m
       ele2=ele
       m=d[k]
       ele=k
print(ele2)

"""#22)find an element k in the list"""

l=[3,2,1,4,5,7,8,9]
k=7
for i in range(len(l)):
  if l[i]==k:
    print(i)
    break
else:
  print("ele nnot found")

"""#23) Find an element in matrix"""

l=[1,2,3],[4,5,6],[7,8,9]             #  input given for mmatrix
k=9
for i in range(len(l)):              # no of rows
  for j in range(len(l[0])):         # len[0] no of columns
    if l[i][j]==k:
      flag=1
      print(True,i,j)
      break
if flag==0:
  print(False)

"""##BINARY SEARCH (DIVIDE AND CONQUER)

Imagine you have a super-duper long list of numbers, all lined up from smallest to biggest, like building blocks! Binary search is like a game to find a special building block (a number) in that list really, really fast.

Here's how you play:

Start in the Middle: You don't start at the beginning. You jump right to the building block exactly in the middle of the list.

Is it Your Block? Look at that middle block. Is it the special number you're looking for?


Yes! Hooray! You found it! Game over, you win!

No, it's too small: If the middle block is smaller than your special number, you know your special number must be in the right half of the list (because the list is sorted!). You can forget about all the blocks in the left half.
No, it's too big: If the middle block is bigger than your special number, you know your special number must be in the left half of the list. You can forget about all the blocks in the right half.


Repeat the Game: Now you have a smaller list of blocks to look through. Go back to step 1 and find the middle block of this new, smaller list. Keep doing this again and again!

Every time you check the middle block, you get rid of half of the remaining blocks! That's why it's so fast. You don't have to look at every single block.

It's like finding a page in a book. You don't start at page 1 and flip one by one. You open somewhere in the middle. If you're past the page you want, you go back to the middle of the first half. If you're before the page you want, you go to the middle of the second half. You keep cutting the book in half until you find your page!


"""

l=[1,3,4,5,7,8,9,11,15]
k=11
s,e=0,len(l)-1
while s<=e:
  m=(s+e)//2
  if l[m]==k:
    print("found the element")
    break
  elif l[m]<k:
    s=m+1
  else:
    e=m-1
else:
  print("false")

"""We have our sorted list of building blocks l = [1, 3, 4, 5, 7, 8, 9, 11, 15] and the special treasure block we're looking for is k = 11.

s, e = 0, len(l)-1: We start with two markers, one at the very beginning of the line of blocks (s is at index 0, the first block) and one at the very end (e is at the last block).

while s < e:: We keep looking as long as our start marker is before our end marker. If they cross or meet, it means we've looked everywhere!

m = (s + e) // 2: We find the block exactly in the middle of where our markers are. This is like finding the middle of our current search area.

if l[m] == k:: We check if the block in the middle l[m] is our special treasure block k.

If it is, we shout "found the element!" and stop the game (break).

elif l[m] < k:: If the middle block is smaller than our treasure, we know our treasure must be in the blocks to the right of the middle block (because they are bigger). So, we move our start marker s to the block after the middle one (m + 1).

else:: If the middle block is bigger than our treasure, we know our treasure must be in the blocks to the left of the middle block (because they are smaller). So, we move our end marker e to the block before the middle one (m - 1).

else: print("false"): If the loop finishes and we haven't found the treasure block (because our start and end markers have met or crossed), it means the treasure wasn't in the list, and we say "false".


So, the code is just doing that middle-checking trick over and over on smaller and smaller parts of the list until it finds the treasure or runs out of places to look!
"""



"""### The `math.ceil()` function in Python

The `math.ceil(x)` function in Python returns the smallest integer greater than or equal to `x`. In simpler terms, it rounds a number *up* to the nearest whole number.

Here are some key points about `math.ceil()`:

*   It's part of the `math` module, so you need to import it first (`import math`).
*   It takes one argument, `x`, which can be a number (integer or float).
*   It always returns an integer.
*   For positive numbers, `math.ceil()` rounds up to the next whole number if there's a decimal part. If it's a whole number, it returns the number itself.
*   For negative numbers, `math.ceil()` rounds up towards zero. For example, `math.ceil(-3.7)` is -3, not -4.

Let's see some examples.
"""

import math

# Positive numbers
print(f"math.ceil(4.2): {math.ceil(4.2)}")
print(f"math.ceil(5): {math.ceil(5)}")
print(f"math.ceil(0.1): {math.ceil(0.1)}")

# Negative numbers
print(f"math.ceil(-2.8): {math.ceil(-2.8)}")
print(f"math.ceil(-3): {math.ceil(-3)}")
print(f"math.ceil(-0.9): {math.ceil(-0.9)}")

# Zero
print(f"math.ceil(0): {math.ceil(0)}")

"""#STACK
stack follows lifo

.append to insert

.pop to remove top element

#QUEUE

queue follows fifo

pop(0) removes first element in queue
"""



s=str(input())
l=[]
for i in s:
  if i not in l:
    l.append(i)

"""#24)how to print numbers in below mentioned pattern pattern
:
"""

l=[3,2,4,2]
n=len(l)
x=3
arr=[]
for i in range(n):
  arr.extend([i+1]*l[i])
print(arr)
l,r=0,0
for i in range(len(arr)):
  if arr[i]==x:
    l=i
    break
for i in range(len(arr)-1,-1,-1):
  if arr[i]==x:
    r=i
    break
print(l,r)

"""###25)input : abbba

###output:aba

###consicutive same element must be removed
"""

arr=str(input("enter the array "))
stack=[]
for i in arr:
  if stack and stack[-1]==i:
    stack.pop()
  else:
    stack.append(i)
print("".join(stack))

arr=str(input())
stack=[]
for i in arr:
  if  i=='*':
    stack.pop()
  else:
    stack.append(i)
print("".join(stack))

"""##26)finding prime numbers by using sevievs erathostheneses algo"""

n=int(input("Enter the number:"))
prime=[True]*(n+1)
prime[0]=False
prime[1]=False
p=2
while p*p<=n:
  if prime[p]:
    for i in range(p*p,n+1,p):
      prime[i]=False
  p+=1
for i in range(n+1):
  if prime[i]:
    print(i,end=' ')

"""#RECCURSION

callling a function inside the same  function is called recsursion

### **Recursion Explained Simply**

Imagine you have a task, and you can break that task down into smaller, similar versions of the same task. Recursion is like saying, "To solve the big task, I'll solve the smaller tasks first."

Think of it like a set of Russian nesting dolls. To open the biggest doll, you have to open the next biggest doll inside. To open that one, you open the next biggest one, and so on, until you get to the smallest doll. Once you open the smallest doll, you can close it up and put it back in the next biggest one, and keep doing that until you've put all the dolls back inside the biggest one.

In programming, a recursive function is a function that calls itself. It keeps calling itself with a smaller version of the problem until it reaches a "base case" – like the smallest nesting doll – where it knows the answer directly without calling itself again. Then, it uses the answers from the smaller problems to solve the bigger ones, all the way back up to the original problem.

**Key Ideas:**

*   **Self-calling:** A function calls itself.
*   **Base Case:** A condition where the function stops calling itself. This is essential to prevent infinite loops.
*   **Smaller Problem:** Each recursive call solves a smaller version of the original problem.

It might sound a bit confusing at first, but it's a powerful way to solve certain problems elegantly!

##27) print the reverse number from the limit mentioned
"""

def fun(n):
    if n==0:             #tail reccursion
      return 0
    print(n)
    fun(n-1)
i=int(input("enter a number"))
fun(i)

"""##28)print the element till the limit by using reccursion"""

def fun(n):
    if n==0:         # head reccursion
      return 0
    fun(n-1)
    print(n)

i=int(input("enter a number"))
fun(i)

"""##29)print the return statement 200"""

def fun(n):
  if n==0:
    return 200
  e=fun(n-1)
  print(n)
  return e


i=int(input("enter a number"))
print(fun(i),end=' ')

def fun(n):
  if n==0:
    return
  if n%2!=0:
    print(n,end=" ")
  fun(n-1)
  if n%2!=0 and n>1:
    print(n,end=" ")
a=int(input())
fun(a)

def fun(n):
  if n==0:
    return
  fun(n-1)
  if n%2!=0:
    print(n,end=" ")

a=int(input())
fun(a)

def fun(n,m=0):
  if n==m:
    return
  print(m+1,end=" ")
  fun(n,m+1)
  print(m+1,end= " ")
a= int(input("enter a num: "))
fun(a)

"""##30)Reduce a number to 1 by performing given operations



Given a number N. The task is to reduce the given number N to 1 in the minimum number of steps.

You can perform any one of the below operations in each step.

Operation 1: If the number is even then you can divide the number by 2.


Operation 2: If the number is odd then you are allowed to perform either (n+1) or (n-1).


You need to print the minimum number of steps required to reduce the number N to 1 by performing the above operations.

Examples:  

Input : n = 15

Output : 5

 15 is odd 15+1=16

 16 is even 16/2=8

 8  is even 8/2=4

 4  is even 4/2=2

 2  is even 2/2=1     

Input : n = 7

Output : 4

    7->6

    6->3

    3->2

    2->1

There is one more way to get in 4 steps :


7->8,  8->4,  4->2,  2->1

"""

def fun(n):
  if n==1:
    return 0
  elif n%2==0:
    return 1+fun(n//2)
  else:
    return 1+min(fun(n+1),fun(n-1))
a=int(input("enter the nums:"))
print(fun(a))

"""##31)check weteher the given number is perfect square or not"""

def fun(n,i=1):
  if i*i==n:
    return True
  elif i*i>n:
    return False
  return fun(n,i+1)

a= int(input("enter the number"))
if fun(a):
  print("perfect")
else:
  print("not perfect")

"""### 32)Fire Simulation

Given a 2D matrix representing a grid where '1' signifies a combustible cell and '0' signifies a non-combustible cell. If a fire starts at a given cell (i, j), and the fire spreads to adjacent combustible cells (up, down, left, and right), write a function to simulate the fire spreading and then count the number of cells that remain unburnt (still '1') after the fire has finished spreading.

**Input:**

*   `matrix`: A list of lists representing the 2D grid.
*   `start_row`: The row index where the fire starts.
*   `start_col`: The column index where the fire starts.

"""

def fire(matrix,i,j):
    if i<0 or i>=len(matrix) or j<0 or j>=len(matrix[0]) or matrix[i][j]!=1:
        return
    matrix[i][j]=2
    fire(matrix,i-1,j)
    fire(matrix,i+1,j)
    fire(matrix,i,j-1)
    fire(matrix,i,j+1)
matrix=[[1,1,0,1],[1,1,0,1],[1,0,0,1],[1,0,1,0]]
fire(matrix,0,0)
count=0
for i in range(len(matrix)):
    for j in range(len(matrix[0])):
        if matrix[i][j]==1:
            count+=1
print(count)

"""###33)Robot Pathfinding Question

Imagine a robot is placed at the top-left corner of a grid. The grid is represented by a matrix where '1' means the robot can move through that cell, and '0' means there is an obstacle. The robot can only move down ('D') or right ('R').

Given the following grid, find all possible paths the robot can take from the top-left corner to the bottom-right corner. Print each valid path as a sequence of 'D' and 'R' characters.
"""

matrix = [[1, 0, 0],
          [1, 1, 0],
          [1, 1, 1]]

# You can use the 'path' function defined earlier to solve this.
# For example:
# path(matrix, 0, 0, "", len(matrix))

def path(grid,i,j,p,n):
  if i==n-1 and j==n-1:
    print(p)
    return
  if i+1<n and grid[i][j]==1:
    path(grid,i+1,j,p+"D",n)
  if j+1<n and grid[i][j]==1:
    path(grid,i,j+1,p+"R",n)

matrix=[[1,0,0],
        [1,1,0],
        [1,1,1]]
path(matrix,0,0,"",len(matrix))

"""###34)fint the size of largest subarray palindrome"""

s="dabac"          #aba is largest palindrome
m=0
for i in range(len(s)):
  r,l=i,i
  while l>=0 and r<len(s) and s[l]==s[r]:
    m=max(m,r-l+1)
    r+=1
    l-=1
print(m)

#this code is only possible for odd palindrome it will throw error for even palindrome "abbacd"an example for even palindrome

s="dabbac"
m=0
for i in range(len(s)):
  r,l=i,i
  while l>=0 and r<len(s) and s[l]==s[r]:
    m=max(m,r-l+1)
    r+=1
    l-=1
  r,l=i+1,i
  while l>=0 and r<len(s) and s[l]==s[r]:
    m=max(m,r-l+1)
    r+=1
    l-=1
print(m)
#to solve the above mentioned problem we use r+1 again

"""###35) find fibonacci number till limit using reccursion"""

def fib(n):
  if n==0:
    return n
  if n==1:
    return(1)
  else:
    return fib(n-1)+fib(n-2)
print(fib(9))

"""this code creates the problem it takes more time and calculate the same fibonanni more than  1 time which is waste of time so we use dynamic programming approach which is much optimized"""

##dp approach
##this is top down approach as it is memeorization
def fib(n,dp):
  if n==1 or n==0:
    return n
  if dp[n]!=-1:
    return dp[n]
  dp[n]=fib(n-1,dp)+fib(n-2,dp)
  return dp[n]

n=int(input("enter the num:"))
dp=[-1]*(n+1)
print(fib(n,dp))

"""we can also make the entire thing top down approach by using for loops tabulation"""

n=int(input("enter the num"))
dp=[-1]*(n+1)
dp[0],dp[1]=0,1
for i in range(2,n+1):
  dp[i]=dp[i-1]+dp[i-2]
print(dp[n])

"""space saving solution"""

n=int(input("enter the nums"))
a,b=0,1
for i in range(2,n+1):
  a,b=b,a+b
print(b)



"""https://takeuforward.org/data-structure/dynamic-programming-introduction/


to learn what dynamic program is and how to solve it

https://takeuforward.org/data-structure/dynamic-programming-climbing-stairs/   

for climbing stairs

https://takeuforward.org/data-structure/dynamic-programming-frog-jump-dp-3/

for frog jump


###36)roblem Statement:

Given a number of stairs and a frog, the frog wants to climb from the 0th stair to the (N-1)th stair. At a time the frog can climb either one or two steps. A height[N] array is also given. Whenever the frog jumps from a stair i to stair j, the energy consumed in the jump is abs(height[i]- height[j]), where abs() means the absolute difference. We need to return the minimum energy that can be used by the frog to jump from stair 0 to stair N-1.
"""

# frog jump dp

def frog_jump(n,energy,dp):
  if n==0:
    return 0
  if dp[n]!=-1:
    return dp[n]
  jump1=frog_jump(n-1,energy,dp)+abs(energy[n]-energy[n-1])
  jump2=float('inf')
  if n>1:
    jump2=frog_jump(n-2,energy,dp)+abs(energy[n]-energy[n-2])
  dp[n]=min(jump1,jump2)
  return dp[n]
energy=[30,10,60,10,60,50]
n=len(energy)-1
dp=[-1]*(n+1)
print(frog_jump(n,energy,dp))

energy =[30,10,60,10,60,50]
n=len(energy)
dp=[-1]*n
dp[0]=0
for i in range(1,n):
  jump1=dp[i-1]+abs(energy[i]-energy[i-1])
  jum2=float('inf')
  if n>1:
    jump2=dp[i-2]+abs(energy[i]-energy[i-2])
  dp[i]=min(jump1,jump2)
print(dp[n-1])

